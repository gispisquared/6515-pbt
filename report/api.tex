\section{API and Specification}

The user facing API for our framework consists of the \verb|test| procedure, as well as the generator constructors for the user to specify inputs.

\subsection{Generator Specification}

We supply primitive generators that produce a value, as well as combinators that take a generator as input to generate complex inputs. Each of our primitive generator constructors return a generator, which is called with no inputs to return a value.
\begin{itemize}
	\item \verb|(g:constant value)|: produces the value \verb|value|.
	\item \verb|(g:integer min max)|: produces integers between \verb|min| and \verb|max|.
	\item \verb|(g:float min max)|: produces a float between \verb|min| and \verb|max|.
	\item \verb|(g:string charset len)|: produces a string with length \verb|len| with characters chosen from \verb|charset|.
	\item \verb|(g:boolean probability)|: produces \verb|#t| with probability \verb|probability|, and \verb|#f| with probability \verb|(- 1 probability)|.
	\item \verb|(g:random-choice choices)|: picks a value in \verb|choices| randomly.
	\item \verb|(g:random-subset choices size)|: picks and returns a list of
	      \verb|size| distinct random values from \verb|choices|.
\end{itemize}

We also supply constructors for combinators that allow users to compose generators arbitrarily.
\begin{itemize}
	\item \verb|(g:cons gen1 gen2)|: produces a \verb|cons|, where the first item is generated from \verb|gen1| and the second from \verb|gen2|.
	\item \verb|(g:list gen len)|: produces a length \verb|len| list of items generated by \verb|gen|.
	\item \verb|(g:amb gen1 gen2 probability)|: generates a value using \verb|gen1| with probability \verb|probability|, and a value from \verb|gen2| otherwise.
	\item \verb|(g:one-of gen1 gen2 ...)|: generates a value using one of the provided generators, all with equal probability.
\end{itemize}

Lastly, we supply a constructor \verb|(g:restrict predicate generator)| which produces a new generator that only generates values that satisfy the predicate.

We can specify our input to our sort function using an integer generator and the list combinator:
\begin{lstlisting}[language=lisp]
(define (integer-list-gen)
  ((g:list (g:integer 0 50) 10)))

(integer-list-gen) ; => (43 1 44 32 28 49 38 42 45 12)
\end{lstlisting}

This defines a new generator \verb|integer-list-gen| that generates a length 10 list of integers between 0 and 50. Suppose we also want to test varying length lists. We can generate the length value itself to produce varying list lengths:

\begin{lstlisting}[language=lisp]
(define (integer-list-gen)
  ((g:list (g:integer 0 50) ((g:integer 0 15)))))

(integer-list-gen) ; => (23 42 2 8 42 10)
\end{lstlisting}

Now, our generator produces a list with length between 0 and 15, with values between 0 and 50. Restricting our values to be prime numbers is as easy as adding a restrict predicate:

\begin{lstlisting}[language=lisp]
(define (integer-list-gen)
  ((g:list (g:restrict prime? (g:integer 0 50)) ((g:integer 0 15)))))

(integer-list-gen) ; => (11 43 23 13)
\end{lstlisting}

\subsection{Testing API}

We define the top level testing procedure as such:
\begin{lstlisting}
(define (test f property generator #!optional times timeout) ...)
\end{lstlisting}

The \verb|test| procedure expects the following types for input:
\begin{itemize}
	\item \verb|f|: a procedure that handles inputs generated by generator.
	\item \verb|property|: a procedure that takes two values, and returns \verb|#t| or \verb|#f|. This function will be called with an \verb|input| generated from \verb|generator|, and \verb|(f input)|.
	\item \verb|generator|: a function taking no inputs that generating a value to be fed into \verb|f|. Expects the generator to be constructed from our supplied constructors, so that the shrinker can reproduce values.
	\item \verb|times| (optional): how many times a value should be generated to attempt to find a counterexample.
	\item \verb|timeout| (optional): how long we should wait before killing a process (for example, we do not want to wait forever for a procedure to finish, should there be an infinite loop).
\end{itemize}

Our \verb|my-sort| function could be tested as:

\begin{lstlisting}[language=lisp]
;; the my-sort function that we'd like to test
(define (my-sort l) ...)          

;; tests that our ouput matches the built-in sort
(define (sorted-version? orig l) 
    (eq-vals? l (sort orig <)))   
    
;; tests that l1 and l2 have the same values
(define (eq-vals? l1 l2) ...)    

;; the generator we wrote previously
(define (integer-list-gen)
  ((g:list (g:integer 0 50) 10)))

(test my-sort sorted-version? integer-list-gen 100) 
    ; => #t
    ; or, perhaps we have a bug
    ; => (0 2 5 5)
\end{lstlisting}

\subsection{Model Based Testing}

We can also use \verb|test| to test that the behavior of two models, such as two implementations of an abstract data type, behave in the same way. Models must be written in a message-passing style, for example for an implementation of a set of integers:
\begin{lstlisting}[language=lisp]
(model 'add 10)    ; => 'done
(model 'delete 10) ; => 'done
(model 'has? 10)   ; => #f
\end{lstlisting}

We define generators for each of the commands, as well as a generator to generate a sequence of commands. We supply a constructor \verb|commands-gen| that takes a list of command generators and generates a list of commands with some maximum length.
\begin{lstlisting}
(define (gen-add)
  (list 'add ((g:integer 0 10))))
(define (gen-remove)
  (list 'remove ((g:integer 0 10))))
(define (gen-has)
  (list 'has ((g:integer 0 10))))
(define (gen-commands)
  ((commands-gen (list gen-has gen-remove gen-add) 100)))
\end{lstlisting}

We can feed this into \verb|test| to test that two implementations behave the same. This could be particularly useful if we make refactoring or performance changes to a model, and want to test that our implementation does not stray from the original. We provide a utility \verb|run-both-models| that takes two models and runs the set of commands on each model.

\begin{lstlisting}[language=lisp]
(test 
  (run-both-models rep-list-set-buggy rep-alist-set)
  (lambda (in out)
    (equal? (car out) (cdr out)))
  gen-commands)) ; => ((add 0) (add 0) (remove 0) (has 0))
\end{lstlisting}
